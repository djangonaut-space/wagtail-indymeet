{"version":3,"file":"viselect.js","sources":["../src/EventEmitter.ts","../src/utils/css.ts","../src/utils/domRect.ts","../src/utils/frames.ts","../src/utils/intersects.ts","../src/utils/browser.ts","../src/utils/arrayify.ts","../src/utils/events.ts","../src/utils/selectAll.ts","../src/utils/matchesTrigger.ts","../src/index.ts"],"sourcesContent":["\n/* eslint-disable @typescript-eslint/no-explicit-any */\ntype AnyFunction = (...args: any[]) => any;\ntype EventMap = Record<string, AnyFunction>;\n\nexport class EventTarget<Events extends EventMap> {\n    private readonly _listeners = new Map<keyof Events, Set<AnyFunction>>();\n\n    public addEventListener<K extends keyof Events>(event: K, cb: Events[K]): this {\n        const set = this._listeners.get(event) ?? new Set();\n        this._listeners.set(event, set);\n        set.add(cb as AnyFunction);\n        return this;\n    }\n\n    public removeEventListener<K extends keyof Events>(event: K, cb: Events[K]): this {\n        this._listeners.get(event)?.delete(cb as AnyFunction);\n        return this;\n    }\n\n    public dispatchEvent<K extends keyof Events>(event: K, ...data: Parameters<Events[K]>): boolean {\n        let ok = true;\n        for (const cb of (this._listeners.get(event) ?? [])) {\n            ok = (cb(...data) !== false) && ok;\n        }\n\n        return ok;\n    }\n\n    public unbindAllListeners(): void {\n        this._listeners.clear();\n    }\n\n    // Let's also support on, off and emit like node\n    public on = this.addEventListener;\n    public off = this.removeEventListener;\n    public emit = this.dispatchEvent;\n}\n","const unitify = (val: string | number, unit = 'px'): string => {\n    return typeof val === 'number' ? val + unit : val;\n};\n\n/**\n * Add css to a DOM-Element or returns the current\n * value of a property.\n *\n * @param el The Element.\n * @param attr The attribute or an object which holds css key-properties.\n * @param val The value for a single attribute.\n * @returns {*}\n */\nexport const css = ({style}: HTMLElement, attr: Partial<Record<keyof CSSStyleDeclaration, string | number>> | string, val?: string | number): void => {\n    if (typeof attr === 'object') {\n        for (const [key, value] of Object.entries(attr)) {\n            if (value !== undefined) {\n                // eslint-disable-next-line @typescript-eslint/no-explicit-any\n                style[key as any] = unitify(value);\n            }\n        }\n    } else if (val !== undefined) {\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        style[attr as any] = unitify(val);\n    }\n};\n\n","// Polyfill for DOMRect as happy-dom and jsdom don't support it\nexport const domRect = (x = 0, y = 0, width = 0, height = 0): DOMRect => {\n    const rect = {x, y, width, height, top: y, left: x, right: x + width, bottom: y + height};\n    const toJSON = () => JSON.stringify(rect);\n    return {...rect, toJSON};\n};\n","/* eslint-disable @typescript-eslint/no-explicit-any */\ntype AnyFunction = (...args: any[]) => void;\n\nexport interface Frames<F extends AnyFunction = AnyFunction> {\n    next(...args: Parameters<F>): void;\n\n    cancel(): void;\n}\n\nexport const frames = <F extends AnyFunction>(fn: F): Frames<F> => {\n    let previousArgs: Parameters<F>;\n    let frameId = -1;\n    let lock = false;\n\n    return {\n        next: (...args: Parameters<F>): void => {\n            previousArgs = args;\n\n            if (!lock) {\n                lock = true;\n                frameId = requestAnimationFrame(() => {\n                    fn(...previousArgs);\n                    lock = false;\n                });\n            }\n        },\n        cancel: () => {\n            cancelAnimationFrame(frameId);\n            lock = false;\n        }\n    };\n};\n","export type Intersection = 'center' | 'cover' | 'touch'\n\n/**\n * Check if two DOM-Elements intersects each other.\n * @param a BoundingClientRect of the first element.\n * @param b BoundingClientRect of the second element.\n * @param mode Options are center, cover or touch.\n * @returns {boolean} If both elements intersects each other.\n */\nexport const intersects = (a: DOMRect, b: DOMRect, mode: Intersection = 'touch'): boolean => {\n    switch (mode) {\n        case 'center': {\n            const bxc = b.left + b.width / 2;\n            const byc = b.top + b.height / 2;\n\n            return bxc >= a.left &&\n                bxc <= a.right &&\n                byc >= a.top &&\n                byc <= a.bottom;\n        }\n        case 'cover': {\n            return b.left >= a.left &&\n                b.top >= a.top &&\n                b.right <= a.right &&\n                b.bottom <= a.bottom;\n        }\n        case 'touch': {\n            return a.right >= b.left &&\n                a.left <= b.right &&\n                a.bottom >= b.top &&\n                a.top <= b.bottom;\n        }\n    }\n};\n","// Determines if the device's primary input supports touch\n// See this article: https://css-tricks.com/touch-devices-not-judged-size/\nexport const isTouchDevice = (): boolean => matchMedia('(hover: none), (pointer: coarse)').matches;\n\n// Determines if the browser is safari\nexport const isSafariBrowser = (): boolean => 'safari' in window;\n","// Turns a value into an array if it's not already an array\nexport const arrayify = <T>(value: T | T[]): T[] => (Array.isArray(value) ? value : [value]);\n","/* eslint-disable @typescript-eslint/no-explicit-any */\nimport {arrayify} from './arrayify';\n\ntype Method = 'addEventListener' | 'removeEventListener';\ntype AnyFunction = (...arg: any) => any;\n\nconst eventListener = (method: Method) => (\n    items: (EventTarget | undefined) | (EventTarget | undefined)[],\n    events: string | string[],\n    fn: AnyFunction,\n    options = {}\n) => {\n\n    // Normalize array\n    if (items instanceof HTMLCollection || items instanceof NodeList) {\n        items = Array.from(items);\n    }\n\n    events = arrayify(events)\n    items = arrayify(items);\n\n    for (const el of items) {\n        if (el) {\n            for (const ev of events) {\n                el[method](ev, fn as EventListener, {capture: false, ...options});\n            }\n        }\n    }\n};\n\n/**\n * Add event(s) to element(s).\n * @param elements DOM-Elements\n * @param events Event names\n * @param fn Callback\n * @param options Optional options\n * @return Array passed arguments\n */\nexport const on = eventListener('addEventListener');\n\n/**\n * Remove event(s) from element(s).\n * @param elements DOM-Elements\n * @param events Event names\n * @param fn Callback\n * @param options Optional options\n * @return Array passed arguments\n */\nexport const off = eventListener('removeEventListener');\n\n/**\n * Simplifies a touch / mouse-event\n * @param evt\n */\nexport const simplifyEvent = (evt: any): {\n    target: HTMLElement;\n    x: number;\n    y: number;\n} => {\n    const {clientX, clientY, target} = evt.touches?.[0] ?? evt;\n    return {x: clientX, y: clientY, target};\n};\n","import {arrayify} from './arrayify';\n\nexport type SelectAllSelectors = (string | Element)[] | string | Element;\n\n/**\n * Takes a selector (or array of selectors) and returns the matched nodes.\n * @param selector The selector or an Array of selectors.\n * @param doc\n * @returns {Array} Array of DOM-Nodes.\n */\nexport const selectAll = (selector: SelectAllSelectors, doc: Document = document): Element[] =>\n    arrayify(selector)\n        .map(item =>\n            typeof item === 'string'\n                ? Array.from(doc.querySelectorAll(item))\n                : item instanceof Element\n                    ? item\n                    : null\n        )\n        .flat()\n        .filter(Boolean) as Element[];\n","\n// https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent/button#value\nexport type MouseButton = 0  // Main\n    | 1  // Auxiliary\n    | 2  // Secondary\n    | 3  // Fourth\n    | 4; // Fifth\n\nexport type Modifier = 'ctrl'\n    | 'alt'\n    | 'shift';\n\nexport type Trigger = MouseButton | MouseButtonWithModifiers;\n\nexport type MouseButtonWithModifiers =  {\n    button: MouseButton,\n    modifiers: Modifier[]\n};\n\n/**\n * Determines whether a MouseEvent should execute until completion depending on\n * which button and modifier(s) are active for the MouseEvent.\n * The Event will execute to completion if ANY of the triggers \"matches\"\n * @param event MouseEvent that should be checked\n * @param triggers A list of Triggers that signify that the event should execute until completion\n * @returns Whether the MouseEvent should execute until completion\n */\nexport const matchesTrigger = (event: MouseEvent, triggers: Trigger[]): boolean =>\n    triggers.some((trigger) => {\n\n        // The trigger requires only a specific button to be pressed\n        if (typeof trigger === 'number') {\n            return event.button === trigger;\n        }\n\n        // The trigger requires a specific button to be pressed AND some modifiers\n        if (typeof trigger === 'object') {\n            if (trigger.button !== event.button) {\n                return false;\n            }\n\n            return trigger.modifiers.every((modifier) => {\n                switch (modifier) {\n                    case 'alt':\n                        return event.altKey;\n                    case 'ctrl':\n                        return event.ctrlKey || event.metaKey;\n                    case 'shift':\n                        return event.shiftKey;\n                }\n            });\n        }\n\n        return false;\n    });\n","import {EventTarget} from './EventEmitter';\nimport type {AreaLocation, Coordinates, ScrollEvent, SelectionEvents, SelectionOptions, SelectionStore} from './types';\nimport {PartialSelectionOptions} from './types';\nimport {css} from './utils/css';\nimport {domRect} from './utils/domRect';\nimport {Frames, frames} from './utils/frames';\nimport {intersects} from './utils/intersects';\nimport {isSafariBrowser, isTouchDevice} from './utils/browser';\nimport {on, off, simplifyEvent} from './utils/events';\nimport {selectAll, SelectAllSelectors} from './utils/selectAll';\nimport {matchesTrigger} from './utils/matchesTrigger';\n\n// Re-export types\nexport * from './types';\n\n// Some var shorting for better compression and readability\nconst {abs, max, min, ceil} = Math;\n\nconst makeSelectionStore = (stored: Element[] = []): SelectionStore => ({\n    stored,\n    selected: [],\n    touched: [],\n    changed: {added: [], removed: []}\n});\n\nexport default class SelectionArea extends EventTarget<SelectionEvents> {\n    public static version = VERSION;\n\n    // Options\n    private readonly _options: SelectionOptions;\n\n    // Selection store\n    private _selection: SelectionStore = makeSelectionStore();\n\n    // Area element and clipping element\n    private readonly _area: HTMLElement;\n    private readonly _clippingElement: HTMLElement;\n\n    // Target container (element) and boundary (cached)\n    private _targetElement?: Element;\n    private _targetBoundary?: Element;\n    private _targetBoundaryScrolled = true;\n    private _targetRect?: DOMRect;\n    private _selectables: Element[] = [];\n    private _latestElement?: Element;\n\n    // Dynamically constructed area rect\n    private _areaLocation: AreaLocation = {y1: 0, x2: 0, y2: 0, x1: 0};\n    private _areaRect = domRect();\n\n    // If a single click is being performed, it's a single-click until the user dragged the mouse\n    private _singleClick = true;\n    private _frame: Frames;\n\n    // Required data for scrolling\n    private _scrollAvailable = true;\n    private _scrollingActive = false;\n    private _scrollSpeed: Coordinates = {x: 0, y: 0};\n    private _scrollDelta: Coordinates = {x: 0, y: 0};\n\n    // Required for keydown scrolling\n    private _lastMousePosition = {x: 0, y: 0};\n\n    constructor(opt: PartialSelectionOptions) {\n        super();\n\n        this._options = {\n            selectionAreaClass: 'selection-area',\n            selectionContainerClass: undefined,\n            selectables: [],\n            document: window.document,\n            startAreas: ['html'],\n            boundaries: ['html'],\n            container: 'body',\n            ...opt,\n\n            behaviour: {\n                overlap: 'invert',\n                intersect: 'touch',\n                triggers: [0],\n                ...opt.behaviour,\n                startThreshold: opt.behaviour?.startThreshold ?\n                    typeof opt.behaviour.startThreshold === 'number' ?\n                        opt.behaviour.startThreshold :\n                        {x: 10, y: 10, ...opt.behaviour.startThreshold} : {x: 10, y: 10},\n                scrolling: {\n                    speedDivider: 10,\n                    manualSpeed: 750,\n                    ...opt.behaviour?.scrolling,\n                    startScrollMargins: {\n                        x: 0,\n                        y: 0,\n                        ...opt.behaviour?.scrolling?.startScrollMargins,\n                    }\n                }\n            },\n\n            features: {\n                range: true,\n                touch: true,\n                deselectOnBlur: false,\n                ...opt.features,\n                singleTap: {\n                    allow: true,\n                    intersect: 'native',\n                    ...opt.features?.singleTap,\n                }\n            }\n        };\n\n        // Bind locale functions to instance\n        /* eslint-disable @typescript-eslint/no-explicit-any */\n        for (const key of Object.getOwnPropertyNames(Object.getPrototypeOf(this))) {\n            if (typeof (this as any)[key] === 'function') {\n                (this as any)[key] = (this as any)[key].bind(this);\n            }\n        }\n\n        const {document, selectionAreaClass, selectionContainerClass} = this._options;\n        this._area = document.createElement('div');\n        this._clippingElement = document.createElement('div');\n        this._clippingElement.appendChild(this._area);\n\n        this._area.classList.add(selectionAreaClass);\n\n        if (selectionContainerClass) {\n            this._clippingElement.classList.add(selectionContainerClass);\n        }\n\n        css(this._area, {\n            willChange: 'top, left, bottom, right, width, height',\n            top: 0,\n            left: 0,\n            position: 'fixed'\n        });\n\n        css(this._clippingElement, {\n            overflow: 'hidden',\n            position: 'fixed',\n            transform: 'translate3d(0, 0, 0)', // https://stackoverflow.com/a/38268846\n            pointerEvents: 'none',\n            zIndex: '1'\n        });\n\n        this._frame = frames((evt: MouseEvent | TouchEvent) => {\n            this._recalculateSelectionAreaRect();\n            this._updateElementSelection();\n            this._emitEvent('move', evt);\n            this._redrawSelectionArea();\n        });\n\n        this.enable();\n    }\n\n    _toggleStartEvents(activate = true): void {\n        const {document, features} = this._options;\n        const fn = activate ? on : off;\n\n        fn(document, 'mousedown', this._onTapStart);\n\n        if (features.touch) {\n            fn(document, 'touchstart', this._onTapStart, {passive: false});\n        }\n    }\n\n    _onTapStart(evt: MouseEvent | TouchEvent, silent = false): void {\n        const {x, y, target} = simplifyEvent(evt);\n        const {document, startAreas, boundaries, features, behaviour} = this._options;\n        const targetBoundingClientRect = target.getBoundingClientRect();\n\n        if (evt instanceof MouseEvent && !matchesTrigger(evt, behaviour.triggers)) {\n            return;\n        }\n\n        // Find start-areas and boundaries\n        const resolvedStartAreas = selectAll(startAreas, document);\n        const resolvedBoundaries = selectAll(boundaries, document);\n\n        // Check in which container the user currently acts\n        this._targetElement = resolvedBoundaries.find(el =>\n            intersects(el.getBoundingClientRect(), targetBoundingClientRect)\n        );\n\n        // Check if the area starts in one of the start areas / boundaries\n        const evtPath = evt.composedPath();\n        const targetStartArea = resolvedStartAreas.find(el => evtPath.includes(el));\n        this._targetBoundary = resolvedBoundaries.find(el => evtPath.includes(el));\n\n        if (!this._targetElement || !targetStartArea || !this._targetBoundary) {\n            return;\n        }\n\n        if (!silent && this._emitEvent('beforestart', evt) === false) {\n            return;\n        }\n\n        this._areaLocation = {x1: x, y1: y, x2: 0, y2: 0};\n\n        // Lock scrolling in the target container\n        const scrollElement = document.scrollingElement ?? document.body;\n        this._scrollDelta = {x: scrollElement.scrollLeft, y: scrollElement.scrollTop};\n\n        // To detect single-click\n        this._singleClick = true;\n        this.clearSelection(false, true);\n\n        on(document, ['touchmove', 'mousemove'], this._delayedTapMove, {passive: false});\n        on(document, ['mouseup', 'touchcancel', 'touchend'], this._onTapStop);\n        on(document, 'scroll', this._onScroll);\n\n        if (features.deselectOnBlur) {\n            this._targetBoundaryScrolled = false;\n            on(this._targetBoundary, 'scroll', this._onStartAreaScroll);\n        }\n    }\n\n    _onSingleTap(evt: MouseEvent | TouchEvent): void {\n        const {singleTap: {intersect}, range} = this._options.features;\n        const e = simplifyEvent(evt);\n        let target;\n\n        if (intersect === 'native') {\n            target = e.target;\n        } else if (intersect === 'touch') {\n            this.resolveSelectables();\n\n            const {x, y} = e;\n            target = this._selectables.find(v => {\n                const {right, left, top, bottom} = v.getBoundingClientRect();\n                return x < right && x > left && y < bottom && y > top;\n            });\n        }\n\n        if (!target) {\n            return;\n        }\n\n        /**\n         * Resolve selectables again.\n         * If the user started in a scrollable area, they will be reduced\n         * to the current area. Prevent the exclusion of these if a range-selection\n         * gets performed.\n         */\n        this.resolveSelectables();\n\n        // Traverse dom upwards to check if the target is selectable\n        while (!this._selectables.includes(target)) {\n            if (target.parentElement) {\n                target = target.parentElement;\n            } else {\n                if (!this._targetBoundaryScrolled) {\n                    this.clearSelection();\n                }\n\n                return;\n            }\n\n        }\n\n        // Grab the current store first in case it gets set back\n        const {stored} = this._selection;\n        this._emitEvent('start', evt);\n\n        if (evt.shiftKey && range && this._latestElement) {\n            const reference = this._latestElement;\n\n            // Resolve the correct range\n            const [preceding, following] = reference.compareDocumentPosition(target) & 4 ?\n                [target, reference] : [reference, target];\n\n            const rangeItems = [...this._selectables.filter(el =>\n                (el.compareDocumentPosition(preceding) & 4) &&\n                (el.compareDocumentPosition(following) & 2)\n            ), preceding, following];\n\n            this.select(rangeItems);\n            this._latestElement = reference; // the latestElement is by default cleared in .select()\n        } else if (\n            stored.includes(target) && (\n                stored.length === 1 || evt.ctrlKey ||\n                stored.every(v => this._selection.stored.includes(v))\n            )\n        ) {\n            this.deselect(target);\n        } else {\n            this.select(target);\n            this._latestElement = target;\n        }\n    }\n\n    _delayedTapMove(evt: MouseEvent | TouchEvent): void {\n        const {container, document, behaviour: {startThreshold}} = this._options;\n        const {x1, y1} = this._areaLocation; // Coordinates of the first \"tap\"\n        const {x, y} = simplifyEvent(evt);\n\n        // Check the pixel threshold\n        if (\n\n            // Single number for both coordinates\n            (typeof startThreshold === 'number' && abs((x + y) - (x1 + y1)) >= startThreshold) ||\n\n            // Different x and y threshold\n            (typeof startThreshold === 'object' && abs(x - x1) >= (startThreshold as Coordinates).x || abs(y - y1) >= (startThreshold as Coordinates).y)\n        ) {\n            off(document, ['mousemove', 'touchmove'], this._delayedTapMove, {passive: false});\n\n            if (this._emitEvent('beforedrag', evt) === false) {\n                off(document, ['mouseup', 'touchcancel', 'touchend'], this._onTapStop);\n                return;\n            }\n\n            on(document, ['mousemove', 'touchmove'], this._onTapMove, {passive: false});\n\n            // Make area element visible\n            css(this._area, 'display', 'block');\n\n            // Append selection-area to the dom\n            selectAll(container, document)[0].appendChild(this._clippingElement);\n\n            this.resolveSelectables();\n\n            // An action is recognized as single-select until the user performed a multi-selection\n            this._singleClick = false;\n\n            // Just saving the boundaries of this container for later\n            this._targetRect = this._targetElement!.getBoundingClientRect();\n\n            // Find a container and check if it's scrollable\n            this._scrollAvailable =\n                this._targetElement!.scrollHeight !== this._targetElement!.clientHeight ||\n                this._targetElement!.scrollWidth !== this._targetElement!.clientWidth;\n\n            if (this._scrollAvailable) {\n\n                // Detect mouse scrolling\n                on(this._targetElement, 'wheel', this._wheelScroll, {passive: false});\n\n                // Detect keyboard scrolling\n                on(this._options.document, 'keydown', this._keyboardScroll, {passive: false});\n\n\n                /**\n                 * The selection-area will also cover another element\n                 * out of the current scrollable parent. So find all elements\n                 * that are in the current scrollable element. Now these are\n                 * the only selectables instead of all.\n                 */\n                this._selectables = this._selectables.filter(s => this._targetElement!.contains(s));\n            }\n\n            // Re-setup selection area and fire event\n            this._setupSelectionArea();\n            this._emitEvent('start', evt);\n            this._onTapMove(evt);\n        }\n\n        this._handleMoveEvent(evt);\n    }\n\n    _setupSelectionArea(): void {\n        const {_clippingElement, _targetElement, _area} = this;\n        const tr = this._targetRect = _targetElement!.getBoundingClientRect();\n\n        if (this._scrollAvailable) {\n\n            /**\n             * To clip the area, the selection area has a parent\n             * which has exactly the same dimensions as the scrollable element.\n             * Now if the area exceeds these boundaries, it will be cropped.\n             */\n            css(_clippingElement, {\n                top: tr.top,\n                left: tr.left,\n                width: tr.width,\n                height: tr.height\n            });\n\n            /**\n             * The area element is relative to the clipping element,\n             * but when this is moved or transformed, we need to correct\n             * the positions via a negative margin.\n             */\n            css(_area, {\n                marginTop: -tr.top,\n                marginLeft: -tr.left\n            });\n        } else {\n\n            // \"Reset\" styles\n            css(_clippingElement, {\n                top: 0,\n                left: 0,\n                width: '100%',\n                height: '100%'\n            });\n\n            css(_area, {\n                marginTop: 0,\n                marginLeft: 0\n            });\n        }\n    }\n\n    _onTapMove(evt: MouseEvent | TouchEvent): void {\n        const {_scrollSpeed, _areaLocation, _options, _frame} = this;\n        const {speedDivider} = _options.behaviour.scrolling;\n        const _targetElement = this._targetElement as Element;\n\n        const {x, y} = simplifyEvent(evt);\n        _areaLocation.x2 = x;\n        _areaLocation.y2 = y;\n\n        this._lastMousePosition.x = x;\n        this._lastMousePosition.y = y;\n\n        if (this._scrollAvailable && !this._scrollingActive && (_scrollSpeed.y || _scrollSpeed.x)) {\n\n            // Continuous scrolling\n            this._scrollingActive = true;\n\n            const scroll = () => {\n                if (!_scrollSpeed.x && !_scrollSpeed.y) {\n                    this._scrollingActive = false;\n                    return;\n                }\n\n                // Reduce velocity, use ceil in both directions to scroll at least 1px per frame\n                const {scrollTop, scrollLeft} = _targetElement;\n\n                if (_scrollSpeed.y) {\n                    _targetElement.scrollTop += ceil(_scrollSpeed.y / speedDivider);\n                    _areaLocation.y1 -= _targetElement.scrollTop - scrollTop;\n                }\n\n                if (_scrollSpeed.x) {\n                    _targetElement.scrollLeft += ceil(_scrollSpeed.x / speedDivider);\n                    _areaLocation.x1 -= _targetElement.scrollLeft - scrollLeft;\n                }\n\n                /**\n                 * We changed the start coordinates -> redraw the selection-area\n                 * We changed the dimensions of the area element -> re-calc selected elements\n                 * The selected elements array has been changed -> fire event\n                 */\n                _frame.next(evt);\n\n                // Keep scrolling even if the user stops to move his pointer\n                requestAnimationFrame(scroll);\n            };\n\n            requestAnimationFrame(scroll);\n        } else {\n\n            /**\n             * Perform redrawing only if scrolling is not active.\n             * If scrolling is active, this area is getting re-dragged by the\n             * anonymize scroll function.\n             */\n            _frame.next(evt);\n        }\n\n        this._handleMoveEvent(evt);\n    }\n\n    _handleMoveEvent(evt: MouseEvent | TouchEvent) {\n        const {features} = this._options;\n\n        /**\n         * - Prevent auto-refresh for when pulling down on touch devices.\n         * - Prevent auto-scroll by the browser when on safari, and scrolling is handled by this library.\n         */\n        if ((features.touch && isTouchDevice()) || (this._scrollAvailable && isSafariBrowser())) {\n            evt.preventDefault(); // Prevent swipe-down refresh\n        }\n    }\n\n    _onScroll(): void {\n        const {_scrollDelta, _options: {document}} = this;\n        const {scrollTop, scrollLeft} = document.scrollingElement ?? document.body;\n\n        // Adjust area start location\n        this._areaLocation.x1 += _scrollDelta.x - scrollLeft;\n        this._areaLocation.y1 += _scrollDelta.y - scrollTop;\n        _scrollDelta.x = scrollLeft;\n        _scrollDelta.y = scrollTop;\n\n        // The area needs to be set back as the target-container has changed in its position\n        this._setupSelectionArea();\n        this._frame.next(null);\n    }\n\n    _onStartAreaScroll(): void {\n        this._targetBoundaryScrolled = true;\n        off(this._targetElement, 'scroll', this._onStartAreaScroll);\n    }\n\n    _wheelScroll(evt: ScrollEvent): void {\n        const {manualSpeed} = this._options.behaviour.scrolling;\n\n        // Consistent scrolling speed on all browsers\n        const deltaY = evt.deltaY ? (evt.deltaY > 0 ? 1 : -1) : 0;\n        const deltaX = evt.deltaX ? (evt.deltaX > 0 ? 1 : -1) : 0;\n        this._scrollSpeed.y += deltaY * manualSpeed;\n        this._scrollSpeed.x += deltaX * manualSpeed;\n        this._onTapMove(evt);\n\n        // Prevent default scrolling behavior, e.g. page scrolling\n        evt.preventDefault();\n    }\n\n    _keyboardScroll(evt: KeyboardEvent): void {\n        const {manualSpeed} = this._options.behaviour.scrolling;\n\n        const deltaX = evt.key === 'ArrowLeft' ? -1 : evt.key === 'ArrowRight' ? 1 : 0;\n        const deltaY = evt.key === 'ArrowUp' ? -1 : evt.key === 'ArrowDown' ? 1 : 0;\n\n        this._scrollSpeed.x += Math.sign(deltaX) * manualSpeed;\n        this._scrollSpeed.y += Math.sign(deltaY) * manualSpeed;\n\n        evt.preventDefault();\n\n        this._onTapMove({\n            clientX: this._lastMousePosition.x,\n            clientY: this._lastMousePosition.y,\n            preventDefault: () => void 0,\n        } as ScrollEvent);\n    }\n\n    _recalculateSelectionAreaRect(): void {\n        const {_scrollSpeed, _areaLocation, _targetElement, _options} = this;\n        const {scrollTop, scrollHeight, clientHeight, scrollLeft, scrollWidth, clientWidth} = _targetElement as Element;\n        const _targetRect = this._targetRect as DOMRect;\n\n        const {x1, y1} = _areaLocation;\n        let {x2, y2} = _areaLocation;\n\n        const {behaviour: {scrolling: {startScrollMargins}}} = _options;\n\n        if (x2 < _targetRect.left + startScrollMargins.x) {\n            _scrollSpeed.x = scrollLeft ? -abs(_targetRect.left - x2 + startScrollMargins.x) : 0;\n            x2 = x2 < _targetRect.left ? _targetRect.left : x2;\n        } else if (x2 > _targetRect.right - startScrollMargins.x) {\n            _scrollSpeed.x = scrollWidth - scrollLeft - clientWidth ? abs(_targetRect.left + _targetRect.width - x2 - startScrollMargins.x) : 0;\n            x2 = x2 > _targetRect.right ? _targetRect.right : x2;\n        } else {\n            _scrollSpeed.x = 0;\n        }\n\n        if (y2 < _targetRect.top + startScrollMargins.y) {\n            _scrollSpeed.y = scrollTop ? -abs(_targetRect.top - y2 + startScrollMargins.y) : 0;\n            y2 = y2 < _targetRect.top ? _targetRect.top : y2;\n        } else if (y2 > _targetRect.bottom - startScrollMargins.y) {\n            _scrollSpeed.y = scrollHeight - scrollTop - clientHeight ? abs(_targetRect.top + _targetRect.height - y2 - startScrollMargins.y) : 0;\n            y2 = y2 > _targetRect.bottom ? _targetRect.bottom : y2;\n        } else {\n            _scrollSpeed.y = 0;\n        }\n\n        const x3 = min(x1, x2);\n        const y3 = min(y1, y2);\n        const x4 = max(x1, x2);\n        const y4 = max(y1, y2);\n\n        this._areaRect = domRect(x3, y3, x4 - x3, y4 - y3);\n    }\n\n    _redrawSelectionArea(): void {\n        const {x, y, width, height} = this._areaRect;\n        const {style} = this._area;\n\n        // Using transform will make the area's borders look blurry\n        style.left = `${x}px`;\n        style.top = `${y}px`;\n        style.width = `${width}px`;\n        style.height = `${height}px`;\n    }\n\n    _onTapStop(evt: MouseEvent | TouchEvent | null, silent: boolean): void {\n        const {document, features} = this._options;\n        const {_singleClick} = this;\n\n        // Remove event handlers\n        off(this._targetElement, 'scroll', this._onStartAreaScroll);\n        off(document, ['mousemove', 'touchmove'], this._delayedTapMove);\n        off(document, ['touchmove', 'mousemove'], this._onTapMove);\n        off(document, ['mouseup', 'touchcancel', 'touchend'], this._onTapStop);\n        off(document, 'scroll', this._onScroll);\n\n        // Keep selection until the next time\n        this._keepSelection();\n\n        if (evt && _singleClick && features.singleTap.allow) {\n            this._onSingleTap(evt);\n        } else if (!_singleClick && !silent) {\n            this._updateElementSelection();\n            this._emitEvent('stop', evt);\n        }\n\n        this._scrollSpeed.x = 0;\n        this._scrollSpeed.y = 0;\n\n        // Unbind mouse scrolling listener\n        off(this._targetElement, 'wheel', this._wheelScroll, {passive: true});\n\n        // Unbind keyboard scrolling listener\n        off(this._options.document, 'keydown', this._keyboardScroll, {passive: true,});\n\n        // Remove selection-area from dom\n        this._clippingElement.remove();\n\n        // Cancel current frame\n        this._frame?.cancel();\n\n        // Hide selection area\n        css(this._area, 'display', 'none');\n    }\n\n    _updateElementSelection(): void {\n        const {_selectables, _options, _selection, _areaRect} = this;\n        const {stored, selected, touched} = _selection;\n        const {intersect, overlap} = _options.behaviour;\n\n        const invert = overlap === 'invert';\n        const newlyTouched: Element[] = [];\n        const added: Element[] = [];\n        const removed: Element[] = [];\n\n        // Find newly selected elements\n        for (let i = 0; i < _selectables.length; i++) {\n            const node = _selectables[i];\n\n            // Check if the area intersects an element\n            if (intersects(_areaRect, node.getBoundingClientRect(), intersect)) {\n\n                // Check if the element wasn't present in the last selection.\n                if (!selected.includes(node)) {\n\n                    // Check if the user wants to invert the selection for already selected elements\n                    if (invert && stored.includes(node)) {\n                        removed.push(node);\n                        continue;\n                    } else {\n                        added.push(node);\n                    }\n                } else if (stored.includes(node) && !touched.includes(node)) {\n                    touched.push(node);\n                }\n\n                newlyTouched.push(node);\n            }\n        }\n\n        // Re-select elements which were previously stored\n        if (invert) {\n            added.push(...stored.filter(v => !selected.includes(v)));\n        }\n\n        // Check which elements where removed since last selection\n        const keep = overlap === 'keep';\n        for (let i = 0; i < selected.length; i++) {\n            const node = selected[i];\n\n            if (!newlyTouched.includes(node) && !(\n\n                // Check if the user wants to keep previously selected elements, e.g.,\n                // not make them part of the current selection as soon as they're touched.\n                keep && stored.includes(node)\n            )) {\n                removed.push(node);\n            }\n        }\n\n        _selection.selected = newlyTouched;\n        _selection.changed = {added, removed};\n\n        // Prevent range selection when selection an area.\n        this._latestElement = undefined;\n    }\n\n    _emitEvent(name: keyof SelectionEvents, evt: MouseEvent | TouchEvent | null): unknown {\n        return this.emit(name, {\n            event: evt,\n            store: this._selection,\n            selection: this\n        });\n    }\n\n    _keepSelection(): void {\n        const {_options, _selection} = this;\n        const {selected, changed, touched, stored} = _selection;\n        const addedElements = selected.filter(el => !stored.includes(el));\n\n        switch (_options.behaviour.overlap) {\n            case 'drop': {\n                _selection.stored = [\n                    ...addedElements,\n                    ...stored.filter(el => !touched.includes(el))  // Elements not touched\n                ];\n                break;\n            }\n            case 'invert': {\n                _selection.stored = [\n                    ...addedElements,\n                    ...stored.filter(el => !changed.removed.includes(el))  // Elements not removed from selection\n                ];\n                break;\n            }\n            case 'keep': {\n                _selection.stored = [\n                    ...stored,\n                    ...selected.filter(el => !stored.includes(el)) // Newly added\n                ];\n                break;\n            }\n        }\n    }\n\n    /**\n     * Manually triggers the start of a selection\n     * @param evt A MouseEvent / TouchEvent-like object\n     * @param silent If beforestart should be fired\n     */\n    trigger(evt: MouseEvent | TouchEvent, silent = true): void {\n        this._onTapStart(evt, silent);\n    }\n\n    /**\n     * Can be used if during a selection elements have been added\n     * Will update everything that can be selected\n     */\n    resolveSelectables(): void {\n        this._selectables = selectAll(this._options.selectables, this._options.document);\n    }\n\n    /**\n     * Same as deselecting, but for all elements currently selected\n     * @param includeStored If the store should also get cleared\n     * @param quiet If move / stop events should be fired\n     */\n    clearSelection(includeStored = true, quiet = false): void {\n        const {selected, stored, changed} = this._selection;\n\n        changed.added = [];\n        changed.removed.push(\n            ...selected,\n            ...(includeStored ? stored : [])\n        );\n\n        // Fire event\n        if (!quiet) {\n            this._emitEvent('move', null);\n            this._emitEvent('stop', null);\n        }\n\n        // Reset state\n        this._selection = makeSelectionStore(includeStored ? [] : stored);\n    }\n\n    /**\n     * @returns {Array} Selected elements\n     */\n    getSelection(): Element[] {\n        return this._selection.stored;\n    }\n\n    /**\n     * @returns {HTMLElement} The selection area element\n     */\n    getSelectionArea(): HTMLElement {\n        return this._area;\n    }\n\n    /**\n     * @returns {Element[]} Available selectable elements for current selection\n     */\n    getSelectables(): Element[] {\n        return this._selectables;\n    }\n\n    /**\n     * Set the location of the selection area\n     * @param location A partial AreaLocation object\n     */\n    setAreaLocation(location: Partial<AreaLocation>) {\n        Object.assign(this._areaLocation, location);\n        this._redrawSelectionArea();\n    }\n\n    /**\n     * @returns {AreaLocation} The current location of the selection area\n     */\n    getAreaLocation(): AreaLocation {\n        return this._areaLocation;\n    }\n\n    /**\n     * Cancel the current selection process, pass true to fire a stop event after cancel\n     * @param keepEvent If a stop event should be fired\n     */\n    cancel(keepEvent = false): void {\n        this._onTapStop(null, !keepEvent);\n    }\n\n    /**\n     * Unbinds all events and removes the area-element.\n     */\n    destroy(): void {\n        this.cancel();\n        this.disable();\n        this._clippingElement.remove();\n        super.unbindAllListeners();\n    }\n\n    /**\n     * Enable selecting elements\n     */\n    enable = this._toggleStartEvents;\n\n    /**\n     * Disable selecting elements\n     */\n    disable = this._toggleStartEvents.bind(this, false);\n\n    /**\n     * Adds elements to the selection\n     * @param query CSS Query, can be an array of queries\n     * @param quiet If this should not trigger the move event\n     */\n    select(query: SelectAllSelectors, quiet = false): Element[] {\n        const {changed, selected, stored} = this._selection;\n        const elements = selectAll(query, this._options.document).filter(el =>\n            !selected.includes(el) &&\n            !stored.includes(el)\n        );\n\n        // Update element lists\n        stored.push(...elements);\n        selected.push(...elements);\n        changed.added.push(...elements);\n        changed.removed = [];\n\n        // We don't know which element was \"selected\" first, so clear it\n        this._latestElement = undefined;\n\n        // Fire event\n        if (!quiet) {\n            this._emitEvent('move', null);\n            this._emitEvent('stop', null);\n        }\n\n        return elements;\n    }\n\n    /**\n     * Removes a particular element from the selection\n     * @param query CSS Query, can be an array of queries\n     * @param quiet If this should not trigger the move event\n     */\n    deselect(query: SelectAllSelectors, quiet = false) {\n        const {selected, stored, changed} = this._selection;\n\n        const elements = selectAll(query, this._options.document).filter(el =>\n            selected.includes(el) ||\n            stored.includes(el)\n        );\n\n        this._selection.stored = stored.filter(el => !elements.includes(el));\n        this._selection.selected = selected.filter(el => !elements.includes(el));\n        this._selection.changed.added = [];\n        this._selection.changed.removed.push(\n            ...elements.filter(el => !changed.removed.includes(el))\n        );\n\n        // We don't know which element was \"selected\" first, so clear it\n        this._latestElement = undefined;\n\n        // Fire event\n        if (!quiet) {\n            this._emitEvent('move', null);\n            this._emitEvent('stop', null);\n        }\n    }\n}\n"],"names":["EventTarget","event","cb","set","_a","data","ok","unitify","val","unit","css","style","attr","key","value","domRect","x","y","width","height","rect","frames","fn","previousArgs","frameId","lock","args","intersects","a","b","mode","bxc","byc","isTouchDevice","isSafariBrowser","arrayify","eventListener","method","items","events","options","el","ev","on","off","simplifyEvent","evt","clientX","clientY","target","selectAll","selector","doc","item","matchesTrigger","triggers","trigger","modifier","abs","max","min","ceil","makeSelectionStore","stored","_SelectionArea","opt","_b","_c","_d","_e","document","selectionAreaClass","selectionContainerClass","activate","features","silent","startAreas","boundaries","behaviour","targetBoundingClientRect","resolvedStartAreas","resolvedBoundaries","evtPath","targetStartArea","scrollElement","intersect","range","e","v","right","left","top","bottom","reference","preceding","following","rangeItems","container","startThreshold","x1","y1","s","_clippingElement","_targetElement","_area","tr","_scrollSpeed","_areaLocation","_options","_frame","speedDivider","scroll","scrollTop","scrollLeft","_scrollDelta","manualSpeed","deltaY","deltaX","scrollHeight","clientHeight","scrollWidth","clientWidth","_targetRect","x2","y2","startScrollMargins","x3","y3","x4","y4","_singleClick","_selectables","_selection","_areaRect","selected","touched","overlap","invert","newlyTouched","added","removed","i","node","keep","name","changed","addedElements","includeStored","quiet","location","keepEvent","query","elements","SelectionArea"],"mappings":"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"}
